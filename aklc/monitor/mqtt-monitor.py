import django
import sys
import os
from django.conf import settings
import paho.mqtt.client as mqtt
import paho.mqtt.publish as publish
import json
import datetime
import time
import pickle
from django.utils import timezone
from django import template
from email.mime.text import MIMEText
#timezone.make_aware(yourdate, timezone.get_current_timezone())

sys.path.append("/code/aklc")
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "aklc.settings")

eMqtt_client_id = os.getenv("AKLC_MQTT_CLIENT_ID", "mqtt_monitor")
eMqtt_host = os.getenv("AKLC_MQTT_HOST", "172.17.0.4")
eMqtt_port = os.getenv("AKLC_MQTT_PORT", "1883")
eMqtt_user = os.getenv("AKLC_MQTT_USER", "")
eMqtt_password = os.getenv("AKLC_MQTT_PASSWORD", "")
eMail_From = os.getenv("AKLC_MAIL_FROM", "info@innovateauckland.nz")
eMail_To = os.getenv("AKLC_MAIL_TO", "westji@aklc.govt.nz")

eMail_topic = os.getenv("AKLC_MAIL_TOPIC", "AKLC/email/send")
sMs_topic = os.getenv("AKLC_SMS_TOPIC", "AKLC/sms/send")

eWeb_Base_URL = os.getenv("AKLC_WEB_BASE_URL", "http://aws2.innovateauckland.nz")

testRunDaily = os.getenv("AKLC_TEST_DAILY", "F")

django.setup()

from monitor.models import Node, Profile, NodeUser, Team
from django.contrib.auth.models import User

# ********************************************************************
def mqtt_on_connect(client, userdata, flags, rc):
    """
      This procedure is called on connection to the mqtt broker
    """
    #global nodes_config
    
    print("Connected to mqtt with result code "+str(rc))
    sub_topic = "AKLC/#"
    client.subscribe(sub_topic)
    print("mqtt Subscribed to " + sub_topic)

    aTeams = Team.objects.all()
    for t in aTeams:
      sub_topic = t.teamID + "/#"
      print(sub_topic)
      client.subscribe(sub_topic)
    
#********************************************************************
def mqtt_on_message(client, userdata, msg):
    """This procedure is called each time a mqtt message is received"""

    #print("mqtt message received {} : {}".format(msg.topic, msg.payload))

    #separate the topic up so we can work with it
    cTopic = msg.topic.split("/")
    cDict = {}
    sPayload = msg.payload.decode()

    # Check for nodes using regular topic structure
    if cTopic[0] == "AKLC":
        #print("Processing AKLC message, next level is |{}|".format(cTopic[1]))
        # Check types of message from the topic
        if "Gateway" == cTopic[1]:
            #print("Processing Gateway message")
            # These are messages from nodes sent on by a gateway
            
            cPayload = sPayload.split(",")   # the payload should be CSV
            
            #print("Node {}, Gateway {}".format(cPayload[1], cPayload[0]))
            if node_validate(cPayload[1]):
                nd, created = Node.objects.get_or_create(nodeID = cPayload[1])
                        
                nd.lastseen = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
                nd.textStatus = "Online"
                nd.status = 'C'
                nd.lastData = sPayload
                nd.save()
          	# Check and update the gateways info
            if node_validate(cPayload[0]):
                gw, created = Node.objects.get_or_create(nodeID = cPayload[0])
                gw.lastseen = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
                gw.isGateway = True
                gw.textStatus = "Online"
                gw.status = "C"
                gw.lastData = sPayload
                gw.save()
              
              
        if cTopic[1] == "Status":      # These are status messages sent by gateways. Data in CSV format
            cPayload = msg.payload.split(",")
            cNode = cPayload[0]             
            #print("Processing status message for {}".format(cNode))
            
            # Check and update the gateways dictionary
            if node_validate(cPayload[0]):
                gw, created = Node.objects.get_or_create(nodeID = cPayload[0])
                        
                gw.lastseen = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
                gw.isGateway = True
                gw.textStatus = "Online"
                gw.status = "C"
                gw.lastData = sPayload
                gw.save()
              

        if cTopic[1] == "Network":      # These are status messages sent by gateways and nodes. Data in JSON format
            jPayload = json.loads(msg.payload)   # the payload should be JSON
            #print("Network status message received from {}".format(cTopic[2]))
            bUpdate = True
            # we need to ignore MQTT messages with a payload that has "Status": "Missing". Those are generated by us!
            if "Status" in jPayload:
                if jPayload["Status"] == "Missing":
                    #print("Picked up a status = missing message")
                    bUpdate = False
            if bUpdate and node_validate(cTopic[2]):
                #print("Processing network message")
                nd, created = Node.objects.get_or_create(nodeID = cTopic[2])
                nd.lastseen = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
                nd.textStatus = "Online"
                nd.status = "C"
                nd.lastData = sPayload
                if nd.battName in jPayload:
                    nd.battValue = jPayload[nd.battName]
                nd.save()

    else:     # not AKLC, a team subscription
      # the payload is expected to be json
      jPayload = json.loads(msg.payload)
      if "NodeID" in jPayload:
        try:
          nd, created = Node.objects.get_or_create(nodeID = jPayload["NodeID"])
          nd.lastseen = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
          nd.textStatus = "Online"
          nd.status = "C"
          nd.lastData = sPayload
          if nd.battName in jPayload:
            nd.battLevel = jPayload[nd.battName]
          if "latitude" in jPayload:
            nd.latitude = jPayload["latitude"]
          if "longitude" in jPayload:
            nd.longitude = jPayload["longitude"]
          if "RSSI" in jPayload:
            nd.RSSI = jPayload["RSSI"]
          try:
            tm = Team.objects.get(teamID = cTopic[0])
            nd.team = tm
          except:
            print("team {} not found".format(cTopic[0]))

          nd.save()
          #print("Processed data for {}".format(nd.nodeID))
        except Exception as e:
          print("NodeID error - {} not in database".format(jPayload["NodeID"]))
          print(e)
  


# ********************************************************************
def node_validate(inNode):
    """Function to validate node names and eliminate Klingon """
    # Only the characters below are accepted in nodeID's
    for c in inNode:
        if c not in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_-':
          print("Invalid char {}".format(c))
          return(False)
    if inNode == "sys-monitor":     # we don't monitor ourself!
        return(False)
    return(True)

#******************************************************************
def missing_node(node, mqtt_client):
  """
  Procedure run when a node has not been seen for a while
  """
  
  if node.status == 'C':                        # only do something if node is currently marked as "C"urrent
    print("Update node {} is down!".format(node.nodeID))
    node.textStatus = "Missing"
    node.status = "X"
    node.notification_sent = True
    node.status_sent = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
    node.save()
    cDict = {'node': node}                      # dict to pass to template
    uNotify = NodeUser.objects.filter(nodeID=node.id)
    for usr in uNotify:
      if usr.email:
        #print(usr.user.email)
        sendNotifyEmail("Node down notification for {}".format(node.nodeID), cDict, "monitor/email-down.html", mqtt_client, usr.user)
        print("Node {} marked as down and email notification sent to {}".format(node.nodeID, usr.user.username))
        usr.lastsms = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
      if usr.sms:
        sendNotifySMS(node, "monitor/sms-down.html", mqtt_client, usr.user)
        print("Node {} marked as down and SMS notification sent to {}".format(node.nodeID, usr.user.username))
        usr.smsSent = True
        usr.lastsms = timezone.make_aware(datetime.datetime.now(), timezone.get_current_timezone())
      usr.save()
  return

# ******************************************************************************
def sendNotifyEmail(inSubject, inDataDict, inTemplate, mqtt_client, mailUser):
    """A function to send email notification
    """
    payload = {}
    try:
        inDataDict['web_base_url'] = eWeb_Base_URL
        inDataDict['user'] = mailUser
        t = template.loader.get_template(inTemplate)
        body = t.render(inDataDict)
      
        msg = MIMEText(body, 'html') 
        msg['From'] = eMail_From
        msg['To'] = mailUser.email
        msg['Subject'] = inSubject
      
        payload['To'] = mailUser.email
        payload['From'] = eMail_From
        #payload['Body'] = msg.as_string()
        #mqtt_client.publish(eMail_topic, json.dumps(payload))

        # test if we can send the body as readable text
        payload['Body'] = body
        payload['Subject'] = inSubject
        mqtt_client.publish(eMail_topic, json.dumps(payload))

    except Exception as e:
        print(e)
        print("Houston, we have an error {}".format(e))  
       
    return

# ******************************************************************************
def sendNotifySMS(inNode, inTemplate, mqtt_client, mailUser):
    """A function to send email notification
    """
    print("Send an SMS to {} about {}".format(mailUser.username, inNode.nodeID))
    payload = {}
    dataDict = {'node': inNode}
    # get to profile which has the phone number
    try:
      uProfile = Profile.objects.get(user = mailUser)
      print("Send sms to {}, his number is {}".format(uProfile, uProfile.phoneNumber))
      dataDict['web_base_url'] = eWeb_Base_URL 
      dataDict['user'] = mailUser
      t = template.loader.get_template(inTemplate)
      body = t.render(dataDict)

      payload['Number'] = uProfile.phoneNumber
      payload["Text"] = body
        
      mqtt_client.publish(sMs_topic, json.dumps(payload))
    except Exception as e:
        print(e)
        print("Houston, we have an error {}".format(e))  
     
    return


#******************************************************************
def sendReport(aNotifyUsers, mqttClient):
  """
  Function collates data and sends a full system report
  """
  print("Sending report")

  # get users to send reports to
  allUsers = Profile.objects.all()
 
  # get all node data for reports
  allNodes = Node.objects.all()
  batWarnList = []
  batCritList=[]
  nodeOKList = []
  nodeDownList = []
  gatewayOKList = []
  gatewayDownList = []
  for a in allNodes:
    if a.isGateway:
      if a.status == 'C':
        gatewayOKList.append(a)
      else:
        gatewayDownList.append(a)
    else:  
      if a.status == 'C':
        #print("Battery name is '{}'".format(a.battName))
        if a.battName == None or a.battLevel == 0:
          nodeOKList.append(a)
        else:
          if a.battLevel > a.battWarn:
            nodeOKList.append(a)
          elif a.battLevel > a.battCritical:
            batWarnList.append(a)
          else:
            batCritList.append(a)
      elif a.status == 'X':
        nodeDownList.append(a)
  cDict = {'nodes': allNodes,
     'nodeOK': nodeOKList,
     'nodeWarn': batWarnList,
     'nodeCrit': batCritList,
     'nodeDown': nodeDownList,
     'gatewayOK': gatewayOKList,
     'gatewayDown': gatewayDownList,
     'web_base_url': eWeb_Base_URL}
  
  #now iterate through users to see what report to send
  for u in allUsers:
    if u.reportType == "F":
      sendNotifyEmail("Daily report", cDict, "monitor/email-full.html", mqttClient, u.user)
    elif u.reportType == "S":
      sendNotifyEmail("Daily summary report", cDict, "monitor/email-summary.html", mqttClient, u.user)
  return


#******************************************************************
def sys_monitor():
    """ The main program that sends updates to the MQTT system
    """

    print("Start function")

    print(eMqtt_client_id)
    print(eMqtt_host)
    print(eMqtt_port)

    #The mqtt client is initialised
    client = mqtt.Client(client_id=eMqtt_client_id)

    #functions called by mqtt client
    client.on_connect = mqtt_on_connect
    client.on_message = mqtt_on_message
    print("MQTT env set up done")

    try:

    # set up the local MQTT environment
        client.username_pw_set(eMqtt_user, eMqtt_password)
        client.connect(eMqtt_host, int(eMqtt_port), 60)
    except Exception as e:
        print(e)

    # used to manage mqtt subscriptions
    client.loop_start()

    #initialise the checkpoint timer
    checkTimer = timezone.now()   

    notification_data = {"LastSummary": datetime.datetime.now() + datetime.timedelta(days = -3)}

    #get any pickled notification data
    try:
        notificationPfile = open("notify.pkl", 'rb')
        notification_data = pickle.load(notificationPfile)
        print("Pickled notification read")
        notificationPfile.close()
    except:
        print("Notification pickle file not found")
        notification_data = {"LastSummary": datetime.datetime.now() + datetime.timedelta(days = -3)}

    if (testRunDaily == "T"):               # if this environment flag is true, run the daily report
      print("Send test daily report")
      allUsers = Profile.objects.all()
      uReport = []
      for usr in allUsers:
        #print("User is {}, email is {}".format(usr.user.user, usr.user.email))
        if usr.reportType == 'F':
            uReport.append(usr.user)
            print("Full report to {}".format(usr.user.email))

      sendReport(uReport, client)

    print("About to start loop")

    while True:
      time.sleep(1)
      
      # this section runs regularly (every 15 sec) and does a number of functions
      if (timezone.now() - checkTimer) > datetime.timedelta(0,15):  #second value is seconds to pause between....
        # update the checkpoint timer
        checkTimer = timezone.now()                                 #reset timer
        
        print("Timer check")
        
        allNodes = Node.objects.all()

        for n in allNodes:
            #if nothing then our 'patience' will run out
            if (timezone.now() - n.lastseen) > datetime.timedelta(minutes=n.allowedDowntime):
                #print("Node {} not seen for over {} minutes".format(n, n.allowedDowntime))
                missing_node(n, client)

      #if (timezone.now() - startTime) > datetime.timedelta(hours=1):    # this section is ony run if the script has been running for an hour
        if (timezone.now().hour > 7):                                   # run at certain time of the day
            #print("Check 1 {}".format(notification_data["LastSummary"]))
            if notification_data["LastSummary"].day != datetime.datetime.now().day:
              print("Send 8am messages")

              allUsers = Profile.objects.all()
              uReport = []
              for usr in allUsers:
                #print("User is {}, email is {}".format(usr.user.username, usr.user.email))
                if usr.reportType == 'F':
                  uReport.append(usr.user)
                  print("Full report to {}".format(usr.user.email))

              sendReport(uReport, client)

              #update out notification data and save
              notification_data["LastSummary"] = datetime.datetime.now()
              #write a pickle containing current notification data
              try:
                  notificationPfile = open("notify.pkl", 'wb')
                  pickle.dump(notification_data, notificationPfile)
                  notificationPfile.close()
              except Exception as e:
                  print(e)
                  print("Notification Pickle failed")



#********************************************************************
if __name__ == "__main__":
    sys_monitor()
